#!/usr/bin/env python
# Copyright Hybrid Logic Ltd.  See LICENSE file for details.

"""
Update the ClusterHQ yum repository with new Flocker packages.

The ClusterHQ yum repository contains packages for Flocker, as well as the
dependencies which aren't available in Fedora 20.  It is currently hosted in
Google's cloud storage.  When doing a release, we want to add the new Flocker
packages, while preserving the existing packages in the repository.  To do
this, we download the current repository, add the new package, update the
metadata, and then upload the repository.

XXX This script is not automatically checked by buildbot. See
https://clusterhq.atlassian.net/browse/FLOC-397
"""

# The plan for this is to have a separate shell and Python script, like other
# admin scripts. However, for the purpose of easy diff-ing for the review
# it will be kept like this temporarily

# TODO put in admin/release
# put RPMs in the right place - we don't want to start uploading random commits as RPMs to the repository, only releases
# not doc releases
# have a weekly repository (folder in a bucket)
# also one for marketing releases (folder in a bucket)
# different bucket for testing
# make fedora-packages
# [clusterhq] and [clusterhq-testing] in clusterhq.repo
# Rewrite with FakeAWS?
# Find Itamar's issue for separating weekly releases with marketing releases
# Centos vs Fedora in
# Make it a verified fake?
# baseurl=https://storage.googleapis.com/archive.clusterhq.com/fedora/$releasever/$basearch/

# Replace /fedora/ with a variable from yum, see yum docs
# what should happen if we add a version which already exists
# no need to upload RPMs which were downloaded already
# in theory X allows you to skip downloading all the packages
# https://github.com/ClusterHQ/flocker/compare/89eb4f4f28c5%5E...d80ae60ccc07
from __future__ import print_function

import os

from subprocess import check_call
from textwrap import dedent
import tempfile

from twisted.python.filepath import FilePath
from twisted.python.usage import Options, UsageError


class UploadOptions(Options):

    optParameters = [
        ["target", None, b'gs://archive.clusterhq.com/',
         "The URL of the download server."],
        ["build-server", None,
         b'http://build.clusterhq.com',
         "The URL of the build-server."]
    ]

    def parseArgs(self, version):
        self['version'] = version


FLOCKER_PACKAGES = [
    b'clusterhq-python-flocker',
    b'clusterhq-flocker-cli',
    b'clusterhq-flocker-node'
]

def update_repo(rpm_directory, target_repo, source_repo, packages):
    # Take a param to say if this is a Fedora or CentOS source.
    # Upload CentOS RPM to S3 / bintray / other.
    # Ask marketing for their statistics requirements and look into the stats
    # opportunities for each.
    """
    Update ``target_repo`` yum repository with ``packages`` from
    ``source_repo`` repository.
    """
    rpm_directory.createDirectory()
    # Download existing repository
    check_call([
        b'gsutil', b'cp', b'-R', target_repo + b'/*', rpm_directory.path])

    # Download requested packages from source repository
    yum_repo_config = rpm_directory.child(b'build.repo')
    yum_repo_config.setContent(dedent(b"""
         [flocker]
         name=flocker
         baseurl=%s
         """) % (source_repo,))
    check_call([
        b'yumdownloader',
        b'-c', yum_repo_config.path,
        b'--disablerepo=*',
        b'--enablerepo=flocker',
        b'--destdir', rpm_directory.path] + packages)
    yum_repo_config.remove()

    # Update repository metatdata
    check_call([b'createrepo', b'--update', rpm_directory.path])

    # Upload updated repository
    check_call(
        [b'gsutil', b'cp', b'-R', b'-a', b'public-read',
         rpm_directory.path + b'/*', target_repo])

def update_centos_repo(rpm_directory, target_repo, source_repo, packages):
    # Take a param to say if this is a Fedora or CentOS source.
    # Upload CentOS RPM to S3 / bintray / other.
    # Ask marketing for their statistics requirements and look into the stats
    # opportunities for each.
    """
    Update ``target_repo`` yum repository with ``packages`` from
    ``source_repo`` repository.
    """
    # TODO change install instructions to point to AWS
    # TODO update the chq release package which is a spec file in another repo
    # https://github.com/ClusterHQ/fedora-packages/blob/master/clusterhq-release.spec
    # https://github.com/ClusterHQ/fedora-packages/blob/master/clusterhq.repo
    # put the old RPMs in there
    rpm_directory.createDirectory()
    # Download existing repository
    import boto
    s3 = boto.connect_s3()
    for bucket in s3.get_all_buckets():
        # bucket.get_key(keyname) does not work if there is a '.' in the key
        # name
        if bucket.name == 'archive-test-adam-dangoor':
            break
    bucket

    # check_call([
#         b'gsutil', b'cp', b'-R', target_repo + b'/*', rpm_directory.path])

    # Download requested packages from source repository
    yum_repo_config = rpm_directory.child(b'build.repo')
    yum_repo_config.setContent(dedent(b"""
         [flocker]
         name=flocker
         baseurl=%s
         """) % (source_repo,))
    check_call([
        b'yumdownloader',
        b'-c', yum_repo_config.path,
        b'--disablerepo=*',
        b'--enablerepo=flocker',
        b'--destdir', rpm_directory.path] + packages)
    yum_repo_config.remove()

    # Update repository metatdata
    check_call([b'createrepo', b'--update', rpm_directory.path])

    # Upload updated repository
    check_call(
        [b'gsutil', b'cp', b'-R', b'-a', b'public-read',
         rpm_directory.path + b'/*', target_repo])


def upload_rpms(scratch_directory, version, target_server, build_server):
    """
    Upload RPMS from build server to yum repository.

    :param FilePath scratch_directory: Temporary directory to download
        repository to.
    :param bytes version: Version to download RPMs for.
    :param bytes target_server: Server to upload RPMs to.
    :param bytes build_server: Server to download new RPMs from.
    """
    # target_base = os.path.join(target_server, b'fedora/20/')
    # source_repo = os.path.join(
    #     build_server, b'results/omnibus', version, 'fedora-20')
    # update_repo(rpm_directory=scratch_directory.child(b'x86_64'),
    #             target_repo=os.path.join(target_base, b'x86_64'),
    #             source_repo=source_repo,
    #             packages=FLOCKER_PACKAGES)

    # Also upload CentOS RPMs
    centos_target_base = os.path.join(target_server, b'centos/7/')
    centos_source_repo = os.path.join(
        build_server, b'results/omnibus', version, 'centos-7')
    update_centos_repo(rpm_directory=scratch_directory.child(b'x86_64'),
                       target_repo=os.path.join(centos_target_base, b'x86_64'),
                       source_repo=centos_source_repo,
                       packages=FLOCKER_PACKAGES)


def main(options):
    version = options['version']

    scratch_directory = FilePath(tempfile.mkdtemp(prefix=b'flocker-upload-rpm-'))

    try:
        upload_rpms(scratch_directory, version,
                    target_server=options['target'],
                    build_server=options['build-server'])

    finally:
        scratch_directory.remove()


if __name__ == '__main__':
    import sys
    options = UploadOptions()
    try:
        options.parseOptions(sys.argv[1:])
    except UsageError as e:
        print('%s: %s' % (sys.argv[0], e))
        raise SystemExit(1)
    main(options)
