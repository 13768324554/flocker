# Copyright Hybrid Logic Ltd.  See LICENSE file for details.

"""
Helper utilities for the Flocker release process.
"""

import sys
from collections import namedtuple

import flocker

from twisted.python.usage import Options, UsageError

import boto


# TODO: Get this from https://github.com/ClusterHQ/flocker/pull/1092
from flocker.docs import get_doc_version, is_release, is_weekly_release


__all__ = ['rpm_version', 'make_rpm_version']

# Use characteristic instead.
# https://clusterhq.atlassian.net/browse/FLOC-1223
rpm_version = namedtuple('rpm_version', 'version release')


def make_rpm_version(flocker_version):
    """
    Parse the Flocker version generated by versioneer into an RPM compatible
    version and a release version.
    See: http://fedoraproject.org/wiki/Packaging:NamingGuidelines#Pre-Release_packages  # noqa

    :param flocker_version: The versioneer style Flocker version string.
    :return: An ``rpm_version`` tuple containing a ``version`` and a
        ``release`` attribute.
    """
    # E.g. 0.1.2-69-gd2ff20c-dirty
    # tag+distance+shortid+dirty
    parts = flocker_version.split('-')
    tag, remainder = parts[0], parts[1:]
    for suffix in ('pre', 'dev'):
        parts = tag.rsplit(suffix, 1)
        if len(parts) == 2:
            # A pre or dev suffix was present. ``version`` is the part before
            # the pre and ``suffix_number`` is the part after the pre, but
            # before the first dash.
            version = parts.pop(0)
            suffix_number = parts[0]
            if suffix_number.isdigit():
                # Given pre or dev number X create a 0 prefixed, `.` separated
                # string of version labels. E.g.
                # 0.1.2pre2  becomes
                # 0.1.2-0.pre.2
                release = ['0', suffix, suffix_number]
            else:
                # Non-integer pre or dev number found.
                raise Exception(
                    'Non-integer value "{}" for "{}". '
                    'Supplied version {}'.format(
                        suffix_number, suffix, flocker_version))
            break
    else:
        # Neither of the expected suffixes was found, the tag can be used as
        # the RPM version
        version = tag
        release = ['1']

    if remainder:
        # The version may also contain a distance, shortid which
        # means that there have been changes since the last
        # tag. Additionally there may be a ``dirty`` suffix which
        # indicates that there are uncommitted changes in the
        # working directory.  We probably don't want to release
        # untagged RPM versions, and this branch should probably
        # trigger and error or a warning. But for now we'll add
        # that extra information to the end of release number.
        # See https://clusterhq.atlassian.net/browse/FLOC-833
        release.extend(remainder)

    return rpm_version(version, '.'.join(release))


class NotARelease(Exception):
    """
    Raised when trying
    """


def configure_s3_routing_rules(doc_version, bucket_name, is_dev):
    s3 = boto.connect_s3()
    bucket = s3.get_bucket(bucket_name)
    config = bucket.get_website_configuration_obj()
    key = 'en/devel/' if is_dev else 'en/latest/'
    rule = [rule for rule in config.routing_rules if
            rule.condition.key_prefix == key][0]
    new_prefix = '/en/%s/' % (doc_version,)
    if rule.redirect.replace_key_prefix == new_prefix:
        return None
    else:
        old_prefix = rule.redirect.replace_key_prefix
        rule.redirect.replace_key_prefix = new_prefix
        print "Setting new bucket configuration: %s redirects to %s" % (
            key, new_prefix)
        #bucket.set_website_configuration()
        return old_prefix


def create_cloudfront_invalidation(doc_version, bucket_name, is_dev,
                                   changed_keys, old_prefix):
    cf = boto.connect_cloudfront()
    s3 = boto.connect_s3()
    distribution = [dist for dist in cf.get_all_distributions()
                    if 'docs.staging.clusterhq.com' in dist.cnames][0]
    if is_dev:
        prefixes = ["/en/devel/"]
    else:
        prefixes = ["/en/latest/"]
    prefixes += ["/en/%s/" % (doc_version,)]

    if old_prefix:
        changed_keys |= s3_get_relative_keys(s3.get_bucket(bucket_name), old_prefix[1:])

    for index in ['index.html', '/index.html']:
        changed_keys |= {key_name[:-len(index)]
                         for key_name in changed_keys
                         if key_name.endswith(index)}

    paths = [prefix + key_name
             for key_name in changed_keys
             for prefix in prefixes]
    print "Invalidating:"
    print '\n'.join(sorted(paths))
    #cf.create_invalidation_request(distribution.id, paths)


def s3_get_relative_keys(bucket, prefix):
    return {key.name[len(prefix):] for key in bucket.list(prefix)}


def copy_docs(flocker_version, doc_version, bucket_name):
    s3 = boto.connect_s3()
    destination_bucket = s3.get_bucket(bucket_name)
    source_bucket = s3.get_bucket('clusterhq-dev-docs')
    source_prefix = '%s/' % (flocker_version,)
    destination_prefix = 'en/%s/' % (doc_version,)

    source_keys = s3_get_relative_keys(source_bucket, source_prefix)
    destination_keys = s3_get_relative_keys(destination_bucket,
                                            destination_prefix)

    keys_to_delete = destination_keys - source_keys
    print "Deleting"
    print "\n".join(
    #destination_bucket.delete_keys(
        [destination_prefix + key_name
         for key_name in keys_to_delete])

    print "Copying:"
    for key_name in source_keys:
        print dict(dest_bucket=bucket_name,
        #destination_bucket.copy_key(
            new_key_name=destination_prefix + key_name,
            src_bucket_name='clusterhq-dev-docs',
            src_key_name=source_prefix + key_name)

    changed_keys = destination_keys | source_keys

    return changed_keys


def publish_docs(flocker_version, doc_version, bucket_name):
    changed_keys = copy_docs(flocker_version, doc_version, bucket_name)

    # Wether the latest, or the devel link should be updated.
    is_devel = not is_release(doc_version)
    old_prefix = configure_s3_routing_rules(
        doc_version=doc_version,
        bucket_name=bucket_name,
        is_dev=is_devel)
    create_cloudfront_invalidation(
        doc_version=doc_version,
        bucket_name=bucket_name,
        changed_keys=changed_keys,
        old_prefix=old_prefix,
        is_dev=is_devel)


class PublishDocsOptions(Options):

    optParameters = [
        ["flocker-version", None, flocker.__version__,
         "The version of flocker from which the documetnation was built."],
        ["doc-version", None, None,
         "The version to publush the documentation as.\n"
         "This will differ from \"flocker-version\" for staging uploads and "
         "documentation releases."],
        ["bucket", None,
         b'clusterhq-staging-docs',
         "The s3 bucket to upload to."]
    ]

    def parseArgs(self):
        if self['doc-version'] is None:
            self['doc-version'] = get_doc_version(self['flocker-version'])


def publish_docs_main(args, base_path, top_level):
    """
    :param list args: The arguments passed to the script.
    :param FilePath base_path: The executable being run.
    :param FilePath top_level: The top-level of the flocker repository.
    """
    options = PublishDocsOptions()

    try:
        options.parseOptions(args)
    except UsageError as e:
        sys.stderr.write("%s: %s\n" % (base_path.basename(), e))
        raise SystemExit(1)

    if not (is_release(options['doc-version'])
            or is_weekly_release(options['doc-version'])):
        sys.stderr.write("%s: Can't publish non-release.")
        raise SystemExit(1)

    publish_docs(
        flocker_version=options['flocker-version'],
        doc_version=options['doc-version'],
        bucket_name=options['bucket'])
