# Copyright Hybrid Logic Ltd.  See LICENSE file for details.

"""
Tests for ``flocker.node.agents.ebs``.
"""

from string import letters
from uuid import uuid4

from hypothesis import given
from hypothesis.strategies import binary, integers, sampled_from, builds

from bitmath import GiB

from twisted.python.filepath import FilePath
from twisted.trial.unittest import SynchronousTestCase

from ..ebs import (
    AttachedUnexpectedDevice, _expected_device,
    _attach_volume_and_wait_for_device, _get_blockdevices,
    _get_device_size,
)
from ..blockdevice import BlockDeviceVolume

from ....testtools import CustomException


# A Hypothesis strategy for generating /dev/sd?
device_path = builds(
    lambda suffix: b"/dev/sd" + suffix,
    suffix=sampled_from(letters),
)


class AttachedUnexpectedDeviceTests(SynchronousTestCase):
    """
    Tests for ``AttachedUnexpectedDevice``.
    """
    def test_repr(self):
        """
        The string representation of ``AttachedUnexpectedDevice`` includes the
        requested device name and the discovered device name.
        """
        requested = FilePath(b"/dev/sda")
        discovered = FilePath(b"/dev/sdb")
        expected = (
            "AttachedUnexpectedDevice("
            "requested='/dev/sda', discovered='/dev/sdb'"
            ")"
        )
        self.assertEqual(
            expected,
            repr(AttachedUnexpectedDevice(requested, discovered))
        )

    def test_nothing_discovered_repr(self):
        """
        If no device is discovered, the repr of ``AttachedUnexpectedDevice``
        shows this with a ``None`` value for ``discovered``.
        """
        requested = FilePath(b"/dev/sda")
        discovered = None
        expected = (
            "AttachedUnexpectedDevice(requested='/dev/sda', discovered=None)"
        )
        self.assertEqual(
            expected,
            repr(AttachedUnexpectedDevice(requested, discovered))
        )

    def test_wrong_requested_type(self):
        """
        If ``AttachedUnexpectedDevice.__init__`` is given something other than
        an instance of ``FilePath`` for the value of ``requested``,
        ``TypeError`` is raised.
        """
        self.assertRaises(
            TypeError, AttachedUnexpectedDevice, object(), FilePath(b"/")
        )

    def test_wrong_discovered_type(self):
        """
        If ``AttachedUnexpectedDevice.__init__`` is given something other than
        ``None`` or an instance of ``FilePath`` for the value of ``requested``,
        ``TypeError`` is raised.
        """
        self.assertRaises(
            TypeError, AttachedUnexpectedDevice, FilePath(b"/"), object(),
        )


class AttachVolumeAndWaitTests(SynchronousTestCase):
    """
    Tests for ``_attach_volume_and_wait_for_device``.
    """
    def setUp(self):
        self.volume = BlockDeviceVolume(
            dataset_id=uuid4(),
            blockdevice_id=u"opaque storage backend id",
            size=int(GiB(100).to_Byte()),
        )
        self.compute_id = u"opaque compute backend id"

    @given(device=device_path, attach_attempt=integers(min_value=1))
    def test_unexpected_attach_exception(self, device, attach_attempt):
        """
        If the ``attach_volume`` function raises an unexpected exception, it is
        passed through.
        """
        def attach_volume(blockdevice_id, compute_id, device):
            raise CustomException("Fake failure generated by test")

        def detach_volume(*a, **kw):
            pass

        self.assertRaises(
            CustomException,
            _attach_volume_and_wait_for_device,
            self.volume, self.compute_id, attach_volume, detach_volume,
            device,
            attach_attempt,
            blockdevices=[],
        )

    @given(
        device=device_path,
        attach_attempt=integers(min_value=1)
    )
    def test_unexpected_device_discovered(self, device, attach_attempt):
        """
        After attaching the volume, if a new device path is discovered that's
        not related to the path given by the ``device`` parameter in the
        expected way, ``AttachedUnexpectedDevice`` is raised giving details
        about the expected and received paths.
        """
        def attach_volume(*a, **kw):
            pass

        def detach_volume(*a, **kw):
            pass

        # The implementation is going to look at the real system to see what
        # block devices exist.  It would be nice to have an abstraction in
        # place to easily manipulate these results for the tests.  Lacking
        # that, just grab the actual block devices from the system and then
        # drop one to make it look like that one has just appeared as a result
        # of the attach operation.
        blockdevices = _get_blockdevices()

        # But there are complex criteria for selection.  So be careful which
        # device we select so as to fool the implementation.
        for wrong_device in blockdevices:
            if wrong_device.basename().startswith((b"sd", b"xvd")):
                size = _get_device_size(wrong_device.basename())
                volume = self.volume.set("size", size)
                blockdevices.remove(wrong_device)
                break
        else:
            self.fail(
                "Could not find a suitable device to use as a dummy bad result"
            )

        exception = self.assertRaises(
            AttachedUnexpectedDevice,
            _attach_volume_and_wait_for_device,
            volume, self.compute_id, attach_volume, detach_volume,
            device,
            attach_attempt,
            blockdevices,
        )
        self.assertEqual(
            AttachedUnexpectedDevice(
                requested=FilePath(device),
                discovered=FilePath(b"/dev/").child(wrong_device.basename()),
            ),
            exception,
        )


class ExpectedDeviceTests(SynchronousTestCase):
    """
    Tests for ``_expected_device``.
    """
    def test_sdX_to_xvdX(self):
        """
        ``sdX``-style devices are rewritten to corresponding ``xvdX`` devices.
        """
        self.assertEqual(
            (FilePath(b"/dev/xvdj"), FilePath(b"/dev/xvdo")),
            (_expected_device(b"/dev/sdj"), _expected_device(b"/dev/sdo")),
        )

    def test_non_dev_rejected(self):
        """
        Devices not in ``/dev`` are rejected with ``ValueError``.
        """
        self.assertRaises(
            ValueError,
            _expected_device, b"/sys/block/sda",
        )

    def test_non_sdX_rejected(self):
        """
        Devices not in the ``sdX`` category are rejected with ``ValueError``.
        """
        self.assertRaises(
            ValueError,
            _expected_device, b"/dev/hda",
        )
